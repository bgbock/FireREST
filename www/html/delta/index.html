<!doctype html>
<html lang="en" ng-app="FireREST">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FireREST&trade;</title>
  <link rel="stylesheet" href="../../css/firerest.css"/>
  <link rel="stylesheet" href="../../bootstrap/css/bootstrap.css"/>
  <script src="../../lib/angular/angular.js"></script>
  <script src="../../lib/angular/angular-route.js"></script>
  <script src="../../lib/jquery/jquery-2.1.1.min.js"></script>
  <script src="../../js/app.js"></script>
  <script src="../../js/services.js"></script>
  <script src="controllers.js"></script>
  <script src="../../bootstrap/js/ui-bootstrap-0.6.0.min.js"></script>
  <script src="../../bootstrap/js/ui-bootstrap-tpls-0.6.0.min.js"></script>
  <script src="../../lib/threejs/three.min.js"></script>

  <style>canvas { width: 100%; height: 100% }</style>
</head>
<body id="body" ng-controller="MainCtrl as main">

<!-- ///////////// BEGIN APPLICATION CODE ///////////// -->

  <div ng-include src="'../../partials/banner.html'" onload="
      bannerTitle='FirePick&trade; Delta Machine Simulator';
      bannerUrl='http://forums.trossenrobotics.com/tutorials/introduction-129/delta-robot-kinematics-3276/';
      bannerName='Delta Machine Simulator';
      bannerIcon='glyphicon-chevron-down'">
  </div>

  <div class="container" >
    <div class="fr-banner-space">&nbsp;</div>

    <div ng-include src="'../../partials/delta.html'"></div>


    <script>
      function makeTextSprite( message, parameters ) {
	parameters =  parameters || { fontsize: 32, backgroundColor: {r:255, g:255, b:100, a:.5} };

	var fontface = parameters.fontface || "Arial";
	var fontsize = parameters.fontsize || 32;
	var borderThickness = parameters.borderThickness !== undefined ? parameters.borderThickness : 4;
	var borderColor = parameters.borderColor || { r:0, g:0, b:0, a:1.0 };
	var backgroundColor = parameters.backgroundColor || { r:255, g:255, b:255, a:0.0 };
	var canvas = document.createElement('canvas');
	canvas.width = 150;
	canvas.height = 150;

	var context = canvas.getContext('2d');
	context.font = fontsize + "px " + fontface;
	  
	// get size data (height depends only on font size)
	var textPad = fontsize / 4;
	var metrics = context.measureText( message );
	var textWidth = metrics.width + textPad + textPad;
	var lineHeight = fontsize;// * 1.4; // 1.4 is extra height factor for text below baseline: g,j,p,q.
	var textX = (canvas.width - textWidth) / 2;
	var textTopY = (canvas.height - lineHeight) / 2;

	context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
	context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," + borderColor.a + ")";
	context.lineWidth = borderThickness;
	var boxW = textWidth+borderThickness;
	var boxH = lineHeight+borderThickness;
	console.log("boxW:"+boxW+" boxH:"+boxH);
	roundRect(context, textX - borderThickness/2, textTopY - borderThickness/2, 
	  textWidth + borderThickness, lineHeight + borderThickness, 6);

	// text color
	context.fillStyle = "rgba(0, 0, 0, 1.0)";
	context.fillText( message, textX+textPad, textTopY + lineHeight * .8);

	// canvas contents will be used for a texture
	var texture = new THREE.Texture(canvas);
	texture.needsUpdate = true;

	var spriteMaterial = new THREE.SpriteMaterial({ map:texture, useScreenCoordinates:false });
	var sprite = new THREE.Sprite( spriteMaterial );
	//sprite.scale.set(80,boxH,1.0);
	sprite.scale.multiplyScalar(boxH);
	console.log("canvasW:" + canvas.width + " H:" + canvas.height);
	return sprite;  
      }

      // function for drawing rounded rectangles
      function roundRect(ctx, x, y, w, h, r) {
	ctx.beginPath();
	ctx.moveTo(x+r, y);
	ctx.lineTo(x+w-r, y);
	ctx.quadraticCurveTo(x+w, y, x+w, y+r);
	ctx.lineTo(x+w, y+h-r);
	ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
	ctx.lineTo(x+r, y+h);
	ctx.quadraticCurveTo(x, y+h, x, y+h-r);
	ctx.lineTo(x, y+r);
	ctx.quadraticCurveTo(x, y, x+r, y);
	ctx.closePath();
	ctx.fill();
	ctx.stroke();   
      }

      var scene = new THREE.Scene();
      var aspectW = 1;
      var aspectH = 1;
      var renderer = new THREE.WebGLRenderer();
      renderer.setSize(500,500);
      
      document.body.appendChild(renderer.domElement);

      var bgBoxGeometry = new THREE.BoxGeometry( 2000, 2000, 2000 );
      var bgBoxMaterial = new THREE.MeshBasicMaterial( { color:0x202020, side:THREE.BackSide } );
      var bgBox = new THREE.Mesh( bgBoxGeometry, bgBoxMaterial );
      scene.add(bgBox);

      var spriteX = makeTextSprite("X");
      spriteX.position.x += 100;
      scene.add(spriteX);
      var spriteY = makeTextSprite("Y");
      spriteY.position.y += 100;
      scene.add(spriteY);
      for (z = -50; z > -500; z -= 50) {
	var spriteZ = makeTextSprite("" + z);
	spriteZ.position.z += z;
	scene.add(spriteZ);
      }

      var rf = 90;
      var f = 190.536;
      var thetaMin = -80*2*Math.PI/360;
      var thetaMax = 80*2*Math.PI/360;
      var pivotMat = new THREE.MeshBasicMaterial({color: 0xFFA62F});
      var guideMat = new THREE.LineDashedMaterial({color: 0x004400, linewidth:2, dashSize: 3, gapSize:3});
      var armMat = new THREE.LineBasicMaterial({color: 0x444488, linewidth:10});
      var baseMat = new THREE.MeshLambertMaterial({ color: 0x88ffff});

      var baseR = f/Math.sqrt(3);
      var baseRin = baseR/2;

      var baseGeom = new THREE.CylinderGeometry( baseR, baseR, 5, 3);        
      var base = new THREE.Mesh( baseGeom, baseMat );
      base.rotation.x += Math.PI/2;
      base.position.set(0,0,0);
      scene.add( base );

      var applyProps = function(props, customProps) {
        for (key in customProps) {
	  if (props.hasOwnProperty(key)) {
	    props[key] = customProps[key];
	  }
	}
	return props;
      }
      //console.log(JSON.stringify(applyProps({a:1,b:2,d:null},{a:11,c:33,d:44})));
      var createArm = function(length, detail) {
        var self = {
	  anglez:0, 
	  ballRadius:3, 
	  ballMat: null,
	  ballGeom: null,
	  armRadius: 1.5,
	  armGeom: null,
	  armMat: null,
	  offset:0
	}
	applyProps(self, detail);
	var position1 = new THREE.Vector3(0,0,0);
	var position2 = new THREE.Vector3(length,0,0);
	self.ballMat = self.ballMat || new THREE.MeshBasicMaterial({color:0xFFA62F}),
	self.ballGeom = self.ballGeom || new THREE.IcosahedronGeometry(self.ballRadius),
	self.armMat = self.armMat || new THREE.LineBasicMaterial({color: 0x444488, linewidth:10});
	self.armGeom = self.armGeom || new THREE.CylinderGeometry( self.armRadius, self.armRadius, length, 24);        
	self.ball1 = new THREE.Mesh(self.ballGeom, self.ballMat);
	self.ball1.position = position1;
	self.ball2 = new THREE.Mesh(self.ballGeom, self.ballMat);
	self.ball2.position = position2;
	self.armMesh = new THREE.Mesh(self.armGeom, self.armMat);
	self.armMesh.rotation.z -= Math.PI/2;
	self.armMesh.position.x += length/2;
	self.arm = new THREE.Object3D();
	self.arm.add(self.armMesh);
	self.arm.add(self.ball1);
	self.arm.add(self.ball2);
	self.offsetGroup = new THREE.Object3D();
	self.offsetGroup.add(self.arm);
	self.offsetGroup.position.x += self.offset;
	self.group = new THREE.Object3D();
	self.group.add(self.offsetGroup);
	return self;
      }
      var baseGuide = new THREE.Object3D();
      var baseGuideGeom = new THREE.CircleGeometry(baseR, 36);
      var baseGuideLine = new THREE.Line(baseGuideGeom, guideMat);
      baseGuide.add(baseGuideLine);

      var arm1 = createArm(rf, {offset:baseRin});
      arm1.group.rotation.z += Math.PI/2;
      arm1.arm.rotation.y += Math.PI/4;
      baseGuide.add(arm1.group);
      var arm2 = createArm(rf, {offset:baseRin});
      arm2.group.rotation.z += Math.PI/2 + 2*Math.PI/3;
      arm2.arm.rotation.y += Math.PI/5;
      baseGuide.add(arm2.group);
      var arm3 = createArm(rf, {offset:baseRin});
      arm3.group.rotation.z += Math.PI/2 - 2*Math.PI/3;
      arm3.arm.rotation.y += Math.PI/6;
      baseGuide.add(arm3.group);

      scene.add(baseGuide);

      var effector = new THREE.Object3D();
      var effectorMat = new THREE.MeshLambertMaterial({ color: 0xff88ff});
      var effectorR = 115/Math.sqrt(3);
      var effectorRin = effectorR/2;
      var effectorGeom = new THREE.CylinderGeometry( effectorRin, effectorRin, 5, 24);        
      var effectorPlate = new THREE.Mesh( effectorGeom, effectorMat );
      effectorPlate.rotation.x += Math.PI/2;
      effector.add( effectorPlate );

      var pivE1Geom = new THREE.IcosahedronGeometry(3);
      var pivE1 = new THREE.Mesh(pivE1Geom, pivotMat);
      pivE1.position.set(0,effectorRin,0);
      effector.add(pivE1);
      var pivE2Geom = new THREE.IcosahedronGeometry(3);
      var pivE2 = new THREE.Mesh(pivE2Geom, pivotMat);
      pivE2.position.set(effectorRin*Math.cos(7*Math.PI/6),effectorRin*Math.sin(7*Math.PI/6),0);
      effector.add(pivE2);
      var pivE3Geom = new THREE.IcosahedronGeometry(3);
      var pivE3 = new THREE.Mesh(pivE3Geom, pivotMat);
      pivE3.position.set(effectorRin*Math.cos(11*Math.PI/6),effectorRin*Math.sin(11*Math.PI/6),0);
      effector.add(pivE3);
      scene.add(effector);

      var blueMat = new THREE.LineBasicMaterial({ color: 0x8888ff });
      var xyGeom = new THREE.Geometry();
      xyGeom.vertices.push( new THREE.Vector3( 100, 0, 0 ) );
      xyGeom.vertices.push( new THREE.Vector3( 0, 0, 0 ) );
      xyGeom.vertices.push( new THREE.Vector3( 0, 100, 0 ) );
      var xyline = new THREE.Line( xyGeom, blueMat );
      scene.add( xyline );
      var zGeom = new THREE.Geometry();
      zGeom.vertices.push( new THREE.Vector3( 0, 0, -100 ) );
      zGeom.vertices.push( new THREE.Vector3( 0, 0, 0 ) );
      var zLine = new THREE.Line( zGeom, blueMat );
      scene.add(zLine);

      var ambient = new THREE.AmbientLight( 0x404040 );
      scene.add(ambient);

      var light1 = new THREE.PointLight( 0xffaaaa, 10, 200 );
      light1.position.set(0,100,-10);
      scene.add( light1 );
      var light2 = new THREE.PointLight( 0xaaaaff, 10, 200 );
      light1.position.set(100,0,-10);
      scene.add( light2 );

      var camera = new THREE.PerspectiveCamera(50, aspectW/aspectH, 0.1, 1000);
      camera.position.z = -50;
      camera.up = new THREE.Vector3(0,0,1);
      camera.lookAt(new THREE.Vector3( 0, 0, -100 ));
      var cameraR = 300;
      var cameraAngle = 0;

      var render = function () {
	var bodyElt = document.getElementById('body');
	//console.log("bodyElt:" + typeof bodyElt);
	var bodyScope = angular.element(bodyElt).scope();
	//console.log("bodyScope:" + typeof bodyScope);
	requestAnimationFrame(render);
	light1.rotation.z += 0.1;
	cameraAngle += 0.01;
	camera.position.x = cameraR * Math.sin(cameraAngle);
	camera.position.y = cameraR * Math.cos(cameraAngle);
	camera.lookAt(new THREE.Vector3( 0, 0, -100 ));
	if ('object' === typeof bodyScope) {
	  effector.position.set( bodyScope.delta.X, bodyScope.delta.Y, bodyScope.delta.Z );
	  //effector.rotation.y += 0.01;
	  //base.rotation.y += 0.01;
	}
	renderer.render(scene, camera);
      };
      render();
    </script>
    {{delta.X}}

<!-- ///////////// END APPLICATION CODE ///////////// -->
<div ng-include src="'../../partials/footer.html'"></div></body></html>
