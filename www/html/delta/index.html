<!doctype html>
<html lang="en" ng-app="FireREST">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FireREST&trade;</title>
  <link rel="stylesheet" href="../../css/firerest.css"/>
  <link rel="stylesheet" href="../../bootstrap/css/bootstrap.css"/>
  <script src="../../lib/angular/angular.js"></script>
  <script src="../../lib/angular/angular-route.js"></script>
  <script src="../../lib/jquery/jquery-2.1.1.min.js"></script>
  <script src="../../js/app.js"></script>
  <script src="../../js/services.js"></script>
  <script src="controllers.js"></script>
  <script src="../../bootstrap/js/ui-bootstrap-0.6.0.min.js"></script>
  <script src="../../bootstrap/js/ui-bootstrap-tpls-0.6.0.min.js"></script>
  <script src="../../lib/threejs/three.min.js"></script>

  <style>canvas { width: 100%; height: 100% }</style>
</head>
<body id="body" ng-controller="MainCtrl as main">

<!-- ///////////// BEGIN APPLICATION CODE ///////////// -->

  <div ng-include src="'../../partials/banner.html'" onload="
      bannerTitle='FirePick&trade; Delta Machine Simulator';
      bannerUrl='http://forums.trossenrobotics.com/tutorials/introduction-129/delta-robot-kinematics-3276/';
      bannerName='Delta Machine Simulator';
      bannerIcon='glyphicon-chevron-down'">
  </div>

  <div class="container" >
    <div class="fr-banner-space">&nbsp;</div>

    <div ng-include src="'../../partials/delta.html'"></div>


    <script>
      function makeTextSprite( message, parameters ) {
	parameters =  parameters || { fontsize: 32, backgroundColor: {r:255, g:255, b:100, a:.5} };

	var fontface = parameters.fontface || "Arial";
	var fontsize = parameters.fontsize || 32;
	var borderThickness = parameters.borderThickness !== undefined ? parameters.borderThickness : 4;
	var borderColor = parameters.borderColor || { r:0, g:0, b:0, a:1.0 };
	var backgroundColor = parameters.backgroundColor || { r:255, g:255, b:255, a:0.0 };
	var canvas = document.createElement('canvas');
	canvas.width = 150;
	canvas.height = 150;

	var context = canvas.getContext('2d');
	context.font = fontsize + "px " + fontface;
	  
	// get size data (height depends only on font size)
	var textPad = fontsize / 4;
	var metrics = context.measureText( message );
	var textWidth = metrics.width + textPad + textPad;
	var lineHeight = fontsize;// * 1.4; // 1.4 is extra height factor for text below baseline: g,j,p,q.
	var textX = (canvas.width - textWidth) / 2;
	var textTopY = (canvas.height - lineHeight) / 2;

	context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
	context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," + borderColor.a + ")";
	context.lineWidth = borderThickness;
	var boxW = textWidth+borderThickness;
	var boxH = lineHeight+borderThickness;
	roundRect(context, textX - borderThickness/2, textTopY - borderThickness/2, 
	  textWidth + borderThickness, lineHeight + borderThickness, 6);

	// text color
	context.fillStyle = "rgba(0, 0, 0, 1.0)";
	context.fillText( message, textX+textPad, textTopY + lineHeight * .8);

	// canvas contents will be used for a texture
	var texture = new THREE.Texture(canvas);
	texture.needsUpdate = true;

	var spriteMaterial = new THREE.SpriteMaterial({ map:texture, useScreenCoordinates:false });
	var sprite = new THREE.Sprite( spriteMaterial );
	//sprite.scale.set(80,boxH,1.0);
	sprite.scale.multiplyScalar(boxH);
	return sprite;  
      }

      // function for drawing rounded rectangles
      function roundRect(ctx, x, y, w, h, r) {
	ctx.beginPath();
	ctx.moveTo(x+r, y);
	ctx.lineTo(x+w-r, y);
	ctx.quadraticCurveTo(x+w, y, x+w, y+r);
	ctx.lineTo(x+w, y+h-r);
	ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
	ctx.lineTo(x+r, y+h);
	ctx.quadraticCurveTo(x, y+h, x, y+h-r);
	ctx.lineTo(x, y+r);
	ctx.quadraticCurveTo(x, y, x+r, y);
	ctx.closePath();
	ctx.fill();
	ctx.stroke();   
      }

      var scene = new THREE.Scene();
      var aspectW = 1;
      var aspectH = 1;
      var renderer = new THREE.WebGLRenderer();
      renderer.setSize(500,500);
      
      document.body.appendChild(renderer.domElement);

      var bgBoxGeometry = new THREE.BoxGeometry( 2000, 2000, 2000 );
      var bgBoxMaterial = new THREE.MeshBasicMaterial( { color:0x202020, side:THREE.BackSide } );
      var bgBox = new THREE.Mesh( bgBoxGeometry, bgBoxMaterial );
      scene.add(bgBox);

      var spriteX = makeTextSprite("X");
      spriteX.position.x += 100;
      scene.add(spriteX);
      var spriteY = makeTextSprite("Y");
      spriteY.position.y += 100;
      scene.add(spriteY);
      for (z = -50; z > -500; z -= 50) {
	var spriteZ = makeTextSprite("" + z);
	spriteZ.position.z += z;
	scene.add(spriteZ);
      }

      var rf = 90;
      var f = 190.536;
      var thetaMin = -80*2*Math.PI/360;
      var thetaMax = 80*2*Math.PI/360;
      var jointMat = new THREE.MeshBasicMaterial({color: 0xFFA62F});
      var guideMat = new THREE.LineDashedMaterial({color: 0x004400, linewidth:2, dashSize: 3, gapSize:3});
      var armMat = new THREE.LineBasicMaterial({color: 0x444488, linewidth:10});
      var baseMat = new THREE.MeshLambertMaterial({ });

      var baseR = f/Math.sqrt(3);
      var baseRin = baseR/2;

      var baseGeom = new THREE.CylinderGeometry( baseR, baseR, 5, 3);        
      var base = new THREE.Mesh( baseGeom, baseMat );
      base.rotation.x += Math.PI/2;
      base.position.set(0,0,0);
      scene.add( base );

      var decorate = function(obj, name, value) {
        if (obj.hasOwnProperty(name)) {
	  throw "Cannot decorate object with existing property:"+name;
	}
	obj[name] = value;
	return obj;
      }
      var applyProps = function(props, customProps) {
        for (key in customProps) {
	  if (props.hasOwnProperty(key)) {
	    props[key] = customProps[key];
	  }
	}
	return props;
      }
      //console.log(JSON.stringify(applyProps({a:1,b:2,d:null},{a:11,c:33,d:44})));
      var createArm = function(length, detail) {
        var self = {
	  ballRadius:3, 
	  ballMat: null,
	  ballGeom: null,
	  armRadius: 1.5,
	  armGeom: null,
	  armMat: null,
	  offset:0
	}
	applyProps(self, detail);
	var position1 = new THREE.Vector3(0,0,0);
	var position2 = new THREE.Vector3(length,0,0);
	self.ballMat = self.ballMat || new THREE.MeshBasicMaterial({color:0xFFA62F}),
	self.ballGeom = self.ballGeom || new THREE.IcosahedronGeometry(self.ballRadius),
	self.armMat = self.armMat || new THREE.LineBasicMaterial({color: 0x444488, linewidth:10});
	self.armGeom = self.armGeom || new THREE.CylinderGeometry( self.armRadius, self.armRadius, length, 24);        
	self.joint = new THREE.Mesh(self.ballGeom, self.ballMat);
	self.joint.position = position1;
	self.tip = new THREE.Mesh(self.ballGeom, self.ballMat);
	self.tip.position = position2;
	self.armMesh = new THREE.Mesh(self.armGeom, self.armMat);
	self.armMesh.rotation.z -= Math.PI/2;
	self.armMesh.position.x += length/2;
	self.arm = new THREE.Object3D();
	self.arm.add(self.armMesh);
	self.arm.add(self.joint);
	self.arm.add(self.tip);
	self.offsetGroup = new THREE.Object3D();
	self.offsetGroup.add(self.arm);
	self.offsetGroup.position.x += self.offset;
	self.group = new THREE.Object3D();
	self.group.add(self.offsetGroup);
	decorate(self.tip, "world", new THREE.Vector3());
	self.updateWorld = function() {
	  self.tip.world.setFromMatrixPosition( self.tip.matrixWorld );
	}
	self.group.updateMatrixWorld();
	return self;
      }
      var createDeltaEffector = function(width, detail) {
        var self = {
	  effector: null, // effector THREE.Object3D
	  ballRadius:3,  // radius for default effector arm joint
	  ballMat: null,  // THREE.Material for default effector arm joint
	  ballGeom: null,  // THREE.Geometry for default effector arm joint
	  width: width,
	  joints:[], // array of three Object3D for arm joints
	  geometry: null, // default effector THREE.Geometry
	  height: 5, // default effector thickness 
	  material: null, // default effector THREE.Material
	  sides: 24, // default effector number of sides
	};
	applyProps(self, detail);
	self.ballMat = self.ballMat || new THREE.MeshBasicMaterial({color:0xFFA62F}),
	self.ballGeom = self.ballGeom || new THREE.IcosahedronGeometry(self.ballRadius),
	self.joints = self.joints.size || [ 
	  new THREE.Mesh(self.ballGeom, self.ballMat),
	  new THREE.Mesh(self.ballGeom, self.ballMat),
	  new THREE.Mesh(self.ballGeom, self.ballMat)
	];
	var radius = 0.5*width/Math.sqrt(3);
	var angle = Math.PI/2;
	self.joints[0].position.set(radius*Math.cos(angle), radius*Math.sin(angle), 0);
	angle += 2*Math.PI/3;
	self.joints[1].position.set(radius*Math.cos(angle), radius*Math.sin(angle), 0);
	angle += 2*Math.PI/3;
	self.joints[2].position.set(radius*Math.cos(angle), radius*Math.sin(angle), 0);
	self.material = self.effectorMat || new THREE.MeshLambertMaterial({});
        self.geometry = self.geometry || new THREE.CylinderGeometry(radius, radius, self.height, self.sides);        
	if (!self.effector) {
	  self.effector = new THREE.Mesh(self.geometry, self.material);
	  self.effector.rotation.x += Math.PI/2;
	}
	self.group = new THREE.Object3D();
	self.group.add(self.effector);
	self.joints.forEach(function(ball){ 
	  self.group.add(ball) 
	  decorate(ball, "world", new THREE.Vector3());
	});
	self.updateWorld = function() {
	  self.joints.forEach(function(ball){ 
	    ball.world.setFromMatrixPosition( ball.matrixWorld );
	  });
	}
	self.group.updateMatrixWorld();
	return self;
      }
      var baseGuide = new THREE.Object3D();
      var baseGuideGeom = new THREE.CircleGeometry(baseR, 36);
      var baseGuideLine = new THREE.Line(baseGuideGeom, guideMat);
      baseGuide.add(baseGuideLine);

      var arm1 = createArm(rf, {offset:baseRin});
      arm1.group.rotation.z += Math.PI/2;
      arm1.arm.rotation.y += Math.PI/4;
      scene.add(arm1.group);
      var arm2 = createArm(rf, {offset:baseRin});
      arm2.group.rotation.z += Math.PI/2 + 2*Math.PI/3;
      arm2.arm.rotation.y += Math.PI/5;
      scene.add(arm2.group);
      var arm3 = createArm(rf, {offset:baseRin});
      arm3.group.rotation.z += Math.PI/2 - 2*Math.PI/3;
      arm3.arm.rotation.y += Math.PI/6;
      scene.add(arm3.group);

      scene.add(baseGuide);

      var effector = createDeltaEffector(115);
      scene.add(effector.group);

      var blueMat = new THREE.LineBasicMaterial({ color:0x8888ff, linewidth:1 });
      var xyGeom = new THREE.Geometry();
      xyGeom.vertices.push( new THREE.Vector3( 100, 0, 0 ) );
      xyGeom.vertices.push( new THREE.Vector3( 0, 0, 0 ) );
      xyGeom.vertices.push( new THREE.Vector3( 0, 100, 0 ) );
      var xyline = new THREE.Line( xyGeom, blueMat );
      scene.add( xyline );
      var zGeom = new THREE.Geometry();
      zGeom.vertices.push( new THREE.Vector3( 0, 0, -100 ) );
      zGeom.vertices.push( new THREE.Vector3( 0, 0, 0 ) );
      var zLine = new THREE.Line( zGeom, blueMat );
      scene.add(zLine);

      scene.updateMatrixWorld();
      var armE1Geom = new THREE.Geometry();
      effector.updateWorld();
      armE1Geom.vertices.push( effector.joints[0].world );
      armE1Geom.vertices.push( arm1.tip.world );
      var armE1Mat = new THREE.LineBasicMaterial({ color:0x88ff88, linewidth:5 });
      var armE1Line = new THREE.Line(armE1Geom, armE1Mat);
      scene.add(armE1Line);
      arm1.arm.rotation.y -= Math.PI/5;
      scene.updateMatrixWorld();
      arm1.updateWorld();

      var ambient = new THREE.AmbientLight( 0x404040 );
      scene.add(ambient);

      var light1 = new THREE.PointLight( 0x88ff88, 1.6, 200 );
      light1.position.set(0,0,-50);
      scene.add( light1 );
      var ringLight1 = new THREE.PointLight( 0xff0000, 1, 200 );
      var angle = -Math.PI/2;
      ringLight1.position.set(100*Math.cos(angle),100*Math.sin(angle),-50);
      scene.add( ringLight1 );
      angle += 2*Math.PI/3;
      var ringLight2 = new THREE.PointLight( 0xff0000, 1, 200 );
      ringLight2.position.set(100*Math.cos(angle),100*Math.sin(angle),-50);
      scene.add( ringLight2 );
      angle += 2*Math.PI/3;
      var ringLight3 = new THREE.PointLight( 0xff0000, 1, 200 );
      ringLight3.position.set(100*Math.cos(angle),100*Math.sin(angle),-50);
      scene.add( ringLight3 );

      var camera = new THREE.PerspectiveCamera(50, aspectW/aspectH, 0.1, 1000);
      camera.position.z = -50;
      camera.up = new THREE.Vector3(0,0,1);
      camera.lookAt(new THREE.Vector3( 0, 0, -100 ));
      var cameraR = 300;
      var cameraAngle = 0;

      var render = function () {
	var bodyElt = document.getElementById('body');
	//console.log("bodyElt:" + typeof bodyElt);
	var bodyScope = angular.element(bodyElt).scope();
	//console.log("bodyScope:" + typeof bodyScope);
	requestAnimationFrame(render);
	cameraAngle += 0.001;
	camera.position.x = cameraR * Math.sin(cameraAngle);
	camera.position.y = cameraR * Math.cos(cameraAngle);
	camera.lookAt(new THREE.Vector3( 0, 0, -100 ));
	if ('object' === typeof bodyScope) {
	  effector.group.position.set( bodyScope.delta.X, bodyScope.delta.Y, bodyScope.delta.Z );
	  arm1.arm.rotation.y = bodyScope.delta.theta1 * Math.PI / 180;
	  arm2.arm.rotation.y = bodyScope.delta.theta2 * Math.PI / 180;
	  arm3.arm.rotation.y = bodyScope.delta.theta3 * Math.PI / 180;
	}
	arm1.updateWorld();
	arm2.updateWorld();
	arm3.updateWorld();
	effector.updateWorld();
	renderer.render(scene, camera);
      };
      render();
    </script>
    delta.theta1:{{delta.theta1}}
    arm1.arm.rotation.y:{{arm1.arm.rotation.y}}

<!-- ///////////// END APPLICATION CODE ///////////// -->
<div ng-include src="'../../partials/footer.html'"></div></body></html>
